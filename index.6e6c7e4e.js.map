{"mappings":"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","sources":["<anon>","js/app.js","node_modules/diff/dist/diff.js"],"sourcesContent":["var $b949b6fb3549d721$exports = {};\n(function(global, factory) {\n    factory($b949b6fb3549d721$exports);\n})($b949b6fb3549d721$exports, function(exports1) {\n    \"use strict\";\n    function Diff() {}\n    Diff.prototype = {\n        diff: function diff(oldString, newString) {\n            var _options$timeout;\n            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            var callback = options.callback;\n            if (typeof options === \"function\") {\n                callback = options;\n                options = {};\n            }\n            this.options = options;\n            var self = this;\n            function done(value) {\n                if (callback) {\n                    setTimeout(function() {\n                        callback(undefined, value);\n                    }, 0);\n                    return true;\n                } else return value;\n            } // Allow subclasses to massage the input prior to running\n            oldString = this.castInput(oldString);\n            newString = this.castInput(newString);\n            oldString = this.removeEmpty(this.tokenize(oldString));\n            newString = this.removeEmpty(this.tokenize(newString));\n            var newLen = newString.length, oldLen = oldString.length;\n            var editLength = 1;\n            var maxEditLength = newLen + oldLen;\n            if (options.maxEditLength) maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n            var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n            var abortAfterTimestamp = Date.now() + maxExecutionTime;\n            var bestPath = [\n                {\n                    oldPos: -1,\n                    lastComponent: undefined\n                }\n            ]; // Seed editLength = 0, i.e. the content starts with the same values\n            var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n            if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) // Identity per the equality and tokenizer\n            return done([\n                {\n                    value: this.join(newString),\n                    count: newString.length\n                }\n            ]);\n             // Once we hit the right edge of the edit graph on some diagonal k, we can\n            // definitely reach the end of the edit graph in no more than k edits, so\n            // there's no point in considering any moves to diagonal k+1 any more (from\n            // which we're guaranteed to need at least k+1 more edits).\n            // Similarly, once we've reached the bottom of the edit graph, there's no\n            // point considering moves to lower diagonals.\n            // We record this fact by setting minDiagonalToConsider and\n            // maxDiagonalToConsider to some finite value once we've hit the edge of\n            // the edit graph.\n            // This optimization is not faithful to the original algorithm presented in\n            // Myers's paper, which instead pointlessly extends D-paths off the end of\n            // the edit graph - see page 7 of Myers's paper which notes this point\n            // explicitly and illustrates it with a diagram. This has major performance\n            // implications for some common scenarios. For instance, to compute a diff\n            // where the new text simply appends d characters on the end of the\n            // original text of length n, the true Myers algorithm will take O(n+d^2)\n            // time while this optimization needs only O(n+d) time.\n            var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.\n            function execEditLength() {\n                for(var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2){\n                    var basePath = void 0;\n                    var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                    if (removePath) // No one else is going to attempt to use this value, clear it\n                    bestPath[diagonalPath - 1] = undefined;\n                    var canAdd = false;\n                    if (addPath) {\n                        // what newPos will be after we do an insertion:\n                        var addPathNewPos = addPath.oldPos - diagonalPath;\n                        canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                    }\n                    var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                    if (!canAdd && !canRemove) {\n                        // If this path is a terminal then prune\n                        bestPath[diagonalPath] = undefined;\n                        continue;\n                    } // Select the diagonal that we want to branch from. We select the prior\n                    // path whose position in the old string is the farthest from the origin\n                    // and does not pass the bounds of the diff graph\n                    // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n                    //       and prefer to order removals before insertions.\n                    if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) basePath = self.addToPath(addPath, true, undefined, 0);\n                    else basePath = self.addToPath(removePath, undefined, true, 1);\n                    newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n                    if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) // If we have hit the end of both strings, then we are done\n                    return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n                    else {\n                        bestPath[diagonalPath] = basePath;\n                        if (basePath.oldPos + 1 >= oldLen) maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                        if (newPos + 1 >= newLen) minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n                editLength++;\n            } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n            // sync and async mode which is never fun. Loops over execEditLength until a value\n            // is produced, or until the edit length exceeds options.maxEditLength (if given),\n            // in which case it will return undefined.\n            if (callback) (function exec() {\n                setTimeout(function() {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) return callback();\n                    if (!execEditLength()) exec();\n                }, 0);\n            })();\n            else while(editLength <= maxEditLength && Date.now() <= abortAfterTimestamp){\n                var ret = execEditLength();\n                if (ret) return ret;\n            }\n        },\n        addToPath: function addToPath(path, added, removed, oldPosInc) {\n            var last = path.lastComponent;\n            if (last && last.added === added && last.removed === removed) return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: {\n                    count: last.count + 1,\n                    added: added,\n                    removed: removed,\n                    previousComponent: last.previousComponent\n                }\n            };\n            else return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: {\n                    count: 1,\n                    added: added,\n                    removed: removed,\n                    previousComponent: last\n                }\n            };\n        },\n        extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n            var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n            while(newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])){\n                newPos++;\n                oldPos++;\n                commonCount++;\n            }\n            if (commonCount) basePath.lastComponent = {\n                count: commonCount,\n                previousComponent: basePath.lastComponent\n            };\n            basePath.oldPos = oldPos;\n            return newPos;\n        },\n        equals: function equals(left, right) {\n            if (this.options.comparator) return this.options.comparator(left, right);\n            else return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n        },\n        removeEmpty: function removeEmpty(array) {\n            var ret = [];\n            for(var i = 0; i < array.length; i++)if (array[i]) ret.push(array[i]);\n            return ret;\n        },\n        castInput: function castInput(value) {\n            return value;\n        },\n        tokenize: function tokenize(value) {\n            return value.split(\"\");\n        },\n        join: function join(chars) {\n            return chars.join(\"\");\n        }\n    };\n    function buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n        // First we convert our linked list of components in reverse order to an\n        // array in the right order:\n        var components = [];\n        var nextComponent;\n        while(lastComponent){\n            components.push(lastComponent);\n            nextComponent = lastComponent.previousComponent;\n            delete lastComponent.previousComponent;\n            lastComponent = nextComponent;\n        }\n        components.reverse();\n        var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;\n        for(; componentPos < componentLen; componentPos++){\n            var component = components[componentPos];\n            if (!component.removed) {\n                if (!component.added && useLongestToken) {\n                    var value = newString.slice(newPos, newPos + component.count);\n                    value = value.map(function(value, i) {\n                        var oldValue = oldString[oldPos + i];\n                        return oldValue.length > value.length ? oldValue : value;\n                    });\n                    component.value = diff.join(value);\n                } else component.value = diff.join(newString.slice(newPos, newPos + component.count));\n                newPos += component.count; // Common case\n                if (!component.added) oldPos += component.count;\n            } else {\n                component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n                oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n                // The diffing algorithm is tied to add then remove output and this is the simplest\n                // route to get the desired output with minimal overhead.\n                if (componentPos && components[componentPos - 1].added) {\n                    var tmp = components[componentPos - 1];\n                    components[componentPos - 1] = components[componentPos];\n                    components[componentPos] = tmp;\n                }\n            }\n        } // Special case handle for when one terminal is ignored (i.e. whitespace).\n        // For this case we merge the terminal into the prior string and drop the change.\n        // This is only available for string mode.\n        var finalComponent = components[componentLen - 1];\n        if (componentLen > 1 && typeof finalComponent.value === \"string\" && (finalComponent.added || finalComponent.removed) && diff.equals(\"\", finalComponent.value)) {\n            components[componentLen - 2].value += finalComponent.value;\n            components.pop();\n        }\n        return components;\n    }\n    var characterDiff = new Diff();\n    function diffChars(oldStr, newStr, options) {\n        return characterDiff.diff(oldStr, newStr, options);\n    }\n    function generateOptions(options, defaults) {\n        if (typeof options === \"function\") defaults.callback = options;\n        else if (options) {\n            for(var name in options)/* istanbul ignore else */ if (options.hasOwnProperty(name)) defaults[name] = options[name];\n        }\n        return defaults;\n    }\n    //\n    // Ranges and exceptions:\n    // Latin-1 Supplement, 0080–00FF\n    //  - U+00D7  × Multiplication sign\n    //  - U+00F7  ÷ Division sign\n    // Latin Extended-A, 0100–017F\n    // Latin Extended-B, 0180–024F\n    // IPA Extensions, 0250–02AF\n    // Spacing Modifier Letters, 02B0–02FF\n    //  - U+02C7  ˇ &#711;  Caron\n    //  - U+02D8  ˘ &#728;  Breve\n    //  - U+02D9  ˙ &#729;  Dot Above\n    //  - U+02DA  ˚ &#730;  Ring Above\n    //  - U+02DB  ˛ &#731;  Ogonek\n    //  - U+02DC  ˜ &#732;  Small Tilde\n    //  - U+02DD  ˝ &#733;  Double Acute Accent\n    // Latin Extended Additional, 1E00–1EFF\n    var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n    var reWhitespace = /\\S/;\n    var wordDiff = new Diff();\n    wordDiff.equals = function(left, right) {\n        if (this.options.ignoreCase) {\n            left = left.toLowerCase();\n            right = right.toLowerCase();\n        }\n        return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n    };\n    wordDiff.tokenize = function(value) {\n        // All whitespace symbols except newline group into one token, each newline - in separate token\n        var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n        for(var i = 0; i < tokens.length - 1; i++)// If we have an empty string in the next field and we have only word chars before and after, merge\n        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n            tokens[i] += tokens[i + 2];\n            tokens.splice(i + 1, 2);\n            i--;\n        }\n        return tokens;\n    };\n    function diffWords(oldStr, newStr, options) {\n        options = generateOptions(options, {\n            ignoreWhitespace: true\n        });\n        return wordDiff.diff(oldStr, newStr, options);\n    }\n    function diffWordsWithSpace(oldStr, newStr, options) {\n        return wordDiff.diff(oldStr, newStr, options);\n    }\n    var lineDiff = new Diff();\n    lineDiff.tokenize = function(value) {\n        if (this.options.stripTrailingCr) // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, \"\\n\");\n        var retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n        if (!linesAndNewlines[linesAndNewlines.length - 1]) linesAndNewlines.pop();\n         // Merge the content and line separators into single tokens\n        for(var i = 0; i < linesAndNewlines.length; i++){\n            var line = linesAndNewlines[i];\n            if (i % 2 && !this.options.newlineIsToken) retLines[retLines.length - 1] += line;\n            else {\n                if (this.options.ignoreWhitespace) line = line.trim();\n                retLines.push(line);\n            }\n        }\n        return retLines;\n    };\n    function diffLines(oldStr, newStr, callback) {\n        return lineDiff.diff(oldStr, newStr, callback);\n    }\n    function diffTrimmedLines(oldStr, newStr, callback) {\n        var options = generateOptions(callback, {\n            ignoreWhitespace: true\n        });\n        return lineDiff.diff(oldStr, newStr, options);\n    }\n    var sentenceDiff = new Diff();\n    sentenceDiff.tokenize = function(value) {\n        return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n    };\n    function diffSentences(oldStr, newStr, callback) {\n        return sentenceDiff.diff(oldStr, newStr, callback);\n    }\n    var cssDiff = new Diff();\n    cssDiff.tokenize = function(value) {\n        return value.split(/([{}:;,]|\\s+)/);\n    };\n    function diffCss(oldStr, newStr, callback) {\n        return cssDiff.diff(oldStr, newStr, callback);\n    }\n    function _typeof(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") _typeof = function(obj) {\n            return typeof obj;\n        };\n        else _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n        return _typeof(obj);\n    }\n    function _defineProperty(obj, key, value) {\n        if (key in obj) Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n        else obj[key] = value;\n        return obj;\n    }\n    function ownKeys(object, enumerableOnly) {\n        var keys = Object.keys(object);\n        if (Object.getOwnPropertySymbols) {\n            var symbols = Object.getOwnPropertySymbols(object);\n            if (enumerableOnly) symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n            keys.push.apply(keys, symbols);\n        }\n        return keys;\n    }\n    function _objectSpread2(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i] != null ? arguments[i] : {};\n            if (i % 2) ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n            else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n            else ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n        return target;\n    }\n    function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n    }\n    function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n    }\n    function _iterableToArray(iter) {\n        if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n        return arr2;\n    }\n    function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var objectPrototypeToString = Object.prototype.toString;\n    var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n    // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n    jsonDiff.useLongestToken = true;\n    jsonDiff.tokenize = lineDiff.tokenize;\n    jsonDiff.castInput = function(value) {\n        var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {\n            return typeof v === \"undefined\" ? undefinedReplacement : v;\n        } : _this$options$stringi;\n        return typeof value === \"string\" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, \"  \");\n    };\n    jsonDiff.equals = function(left, right) {\n        return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, \"$1\"), right.replace(/,([\\r\\n])/g, \"$1\"));\n    };\n    function diffJson(oldObj, newObj, options) {\n        return jsonDiff.diff(oldObj, newObj, options);\n    } // This function handles the presence of circular references by bailing out when encountering an\n    // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n    function canonicalize(obj, stack, replacementStack, replacer, key) {\n        stack = stack || [];\n        replacementStack = replacementStack || [];\n        if (replacer) obj = replacer(key, obj);\n        var i;\n        for(i = 0; i < stack.length; i += 1){\n            if (stack[i] === obj) return replacementStack[i];\n        }\n        var canonicalizedObj;\n        if (\"[object Array]\" === objectPrototypeToString.call(obj)) {\n            stack.push(obj);\n            canonicalizedObj = new Array(obj.length);\n            replacementStack.push(canonicalizedObj);\n            for(i = 0; i < obj.length; i += 1)canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n            stack.pop();\n            replacementStack.pop();\n            return canonicalizedObj;\n        }\n        if (obj && obj.toJSON) obj = obj.toJSON();\n        if (_typeof(obj) === \"object\" && obj !== null) {\n            stack.push(obj);\n            canonicalizedObj = {};\n            replacementStack.push(canonicalizedObj);\n            var sortedKeys = [], _key;\n            for(_key in obj)/* istanbul ignore else */ if (obj.hasOwnProperty(_key)) sortedKeys.push(_key);\n            sortedKeys.sort();\n            for(i = 0; i < sortedKeys.length; i += 1){\n                _key = sortedKeys[i];\n                canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n            }\n            stack.pop();\n            replacementStack.pop();\n        } else canonicalizedObj = obj;\n        return canonicalizedObj;\n    }\n    var arrayDiff = new Diff();\n    arrayDiff.tokenize = function(value) {\n        return value.slice();\n    };\n    arrayDiff.join = arrayDiff.removeEmpty = function(value) {\n        return value;\n    };\n    function diffArrays(oldArr, newArr, callback) {\n        return arrayDiff.diff(oldArr, newArr, callback);\n    }\n    function parsePatch(uniDiff) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/), delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [], list = [], i = 0;\n        function parseIndex() {\n            var index = {};\n            list.push(index); // Parse diff metadata\n            while(i < diffstr.length){\n                var line = diffstr[i]; // File header found, end parsing diff metadata\n                if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) break;\n                 // Diff index\n                var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n                if (header) index.index = header[1];\n                i++;\n            } // Parse file headers if they are defined. Unified diff requires them, but\n            // there's no technical issues to have an isolated hunk without file header\n            parseFileHeader(index);\n            parseFileHeader(index); // Parse hunks\n            index.hunks = [];\n            while(i < diffstr.length){\n                var _line = diffstr[i];\n                if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) break;\n                else if (/^@@/.test(_line)) index.hunks.push(parseHunk());\n                else if (_line && options.strict) // Ignore unexpected content unless in strict mode\n                throw new Error(\"Unknown line \" + (i + 1) + \" \" + JSON.stringify(_line));\n                else i++;\n            }\n        } // Parses the --- and +++ headers, if none are found, no lines\n        // are consumed.\n        function parseFileHeader(index) {\n            var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n            if (fileHeader) {\n                var keyPrefix = fileHeader[1] === \"---\" ? \"old\" : \"new\";\n                var data = fileHeader[2].split(\"\t\", 2);\n                var fileName = data[0].replace(/\\\\\\\\/g, \"\\\\\");\n                if (/^\".*\"$/.test(fileName)) fileName = fileName.substr(1, fileName.length - 2);\n                index[keyPrefix + \"FileName\"] = fileName;\n                index[keyPrefix + \"Header\"] = (data[1] || \"\").trim();\n                i++;\n            }\n        } // Parses a hunk\n        // This assumes that we are at the start of a hunk.\n        function parseHunk() {\n            var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n            var hunk = {\n                oldStart: +chunkHeader[1],\n                oldLines: typeof chunkHeader[2] === \"undefined\" ? 1 : +chunkHeader[2],\n                newStart: +chunkHeader[3],\n                newLines: typeof chunkHeader[4] === \"undefined\" ? 1 : +chunkHeader[4],\n                lines: [],\n                linedelimiters: []\n            }; // Unified Diff Format quirk: If the chunk size is 0,\n            // the first number is one lower than one would expect.\n            // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n            if (hunk.oldLines === 0) hunk.oldStart += 1;\n            if (hunk.newLines === 0) hunk.newStart += 1;\n            var addCount = 0, removeCount = 0;\n            for(; i < diffstr.length; i++){\n                // Lines starting with '---' could be mistaken for the \"remove line\" operation\n                // But they could be the header for the next file. Therefore prune such cases out.\n                if (diffstr[i].indexOf(\"--- \") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf(\"+++ \") === 0 && diffstr[i + 2].indexOf(\"@@\") === 0) break;\n                var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? \" \" : diffstr[i][0];\n                if (operation === \"+\" || operation === \"-\" || operation === \" \" || operation === \"\\\\\") {\n                    hunk.lines.push(diffstr[i]);\n                    hunk.linedelimiters.push(delimiters[i] || \"\\n\");\n                    if (operation === \"+\") addCount++;\n                    else if (operation === \"-\") removeCount++;\n                    else if (operation === \" \") {\n                        addCount++;\n                        removeCount++;\n                    }\n                } else break;\n            } // Handle the empty block count case\n            if (!addCount && hunk.newLines === 1) hunk.newLines = 0;\n            if (!removeCount && hunk.oldLines === 1) hunk.oldLines = 0;\n             // Perform optional sanity checking\n            if (options.strict) {\n                if (addCount !== hunk.newLines) throw new Error(\"Added line count did not match for hunk at line \" + (chunkHeaderIndex + 1));\n                if (removeCount !== hunk.oldLines) throw new Error(\"Removed line count did not match for hunk at line \" + (chunkHeaderIndex + 1));\n            }\n            return hunk;\n        }\n        while(i < diffstr.length)parseIndex();\n        return list;\n    }\n    // Iterator that traverses in the range of [min, max], stepping\n    // by distance from a given start position. I.e. for [0, 4], with\n    // start of 2, this will iterate 2, 3, 1, 4, 0.\n    function distanceIterator(start, minLine, maxLine) {\n        var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;\n        return function iterator() {\n            if (wantForward && !forwardExhausted) {\n                if (backwardExhausted) localOffset++;\n                else wantForward = false;\n                 // Check if trying to fit beyond text length, and if not, check it fits\n                // after offset location (or desired location on first iteration)\n                if (start + localOffset <= maxLine) return localOffset;\n                forwardExhausted = true;\n            }\n            if (!backwardExhausted) {\n                if (!forwardExhausted) wantForward = true;\n                 // Check if trying to fit before text beginning, and if not, check it fits\n                // before offset location\n                if (minLine <= start - localOffset) return -localOffset++;\n                backwardExhausted = true;\n                return iterator();\n            } // We tried to fit hunk before text beginning and beyond text length, then\n        // hunk can't fit on the text. Return undefined\n        };\n    }\n    function applyPatch(source, uniDiff) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (typeof uniDiff === \"string\") uniDiff = parsePatch(uniDiff);\n        if (Array.isArray(uniDiff)) {\n            if (uniDiff.length > 1) throw new Error(\"applyPatch only works with a single input.\");\n            uniDiff = uniDiff[0];\n        } // Apply the diff to the input\n        var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/), delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {\n            return line === patchContent;\n        }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;\n        /**\n     * Checks if the hunk exactly fits on the provided location\n     */ function hunkFits(hunk, toPos) {\n            for(var j = 0; j < hunk.lines.length; j++){\n                var line = hunk.lines[j], operation = line.length > 0 ? line[0] : \" \", content = line.length > 0 ? line.substr(1) : line;\n                if (operation === \" \" || operation === \"-\") {\n                    // Context sanity check\n                    if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n                        errorCount++;\n                        if (errorCount > fuzzFactor) return false;\n                    }\n                    toPos++;\n                }\n            }\n            return true;\n        } // Search best fit offsets for each hunk based on the previous ones\n        for(var i = 0; i < hunks.length; i++){\n            var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;\n            var iterator = distanceIterator(toPos, minLine, maxLine);\n            for(; localOffset !== undefined; localOffset = iterator())if (hunkFits(hunk, toPos + localOffset)) {\n                hunk.offset = offset += localOffset;\n                break;\n            }\n            if (localOffset === undefined) return false;\n             // Set lower text limit to end of the current hunk, so next ones don't try\n            // to fit over already patched text\n            minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n        } // Apply patch hunks\n        var diffOffset = 0;\n        for(var _i = 0; _i < hunks.length; _i++){\n            var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n            diffOffset += _hunk.newLines - _hunk.oldLines;\n            for(var j = 0; j < _hunk.lines.length; j++){\n                var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : \" \", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || \"\\n\";\n                if (operation === \" \") _toPos++;\n                else if (operation === \"-\") {\n                    lines.splice(_toPos, 1);\n                    delimiters.splice(_toPos, 1);\n                /* istanbul ignore else */ } else if (operation === \"+\") {\n                    lines.splice(_toPos, 0, content);\n                    delimiters.splice(_toPos, 0, delimiter);\n                    _toPos++;\n                } else if (operation === \"\\\\\") {\n                    var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n                    if (previousOperation === \"+\") removeEOFNL = true;\n                    else if (previousOperation === \"-\") addEOFNL = true;\n                }\n            }\n        } // Handle EOFNL insertion/removal\n        if (removeEOFNL) while(!lines[lines.length - 1]){\n            lines.pop();\n            delimiters.pop();\n        }\n        else if (addEOFNL) {\n            lines.push(\"\");\n            delimiters.push(\"\\n\");\n        }\n        for(var _k = 0; _k < lines.length - 1; _k++)lines[_k] = lines[_k] + delimiters[_k];\n        return lines.join(\"\");\n    } // Wrapper that supports multiple file patches via callbacks.\n    function applyPatches(uniDiff, options) {\n        if (typeof uniDiff === \"string\") uniDiff = parsePatch(uniDiff);\n        var currentIndex = 0;\n        function processIndex() {\n            var index = uniDiff[currentIndex++];\n            if (!index) return options.complete();\n            options.loadFile(index, function(err, data) {\n                if (err) return options.complete(err);\n                var updatedContent = applyPatch(data, index, options);\n                options.patched(index, updatedContent, function(err) {\n                    if (err) return options.complete(err);\n                    processIndex();\n                });\n            });\n        }\n        processIndex();\n    }\n    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n        if (!options) options = {};\n        if (typeof options.context === \"undefined\") options.context = 4;\n        var diff = diffLines(oldStr, newStr, options);\n        if (!diff) return;\n        diff.push({\n            value: \"\",\n            lines: []\n        }); // Append an empty value to make cleanup easier\n        function contextLines(lines) {\n            return lines.map(function(entry) {\n                return \" \" + entry;\n            });\n        }\n        var hunks = [];\n        var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;\n        var _loop = function _loop(i) {\n            var current = diff[i], lines = current.lines || current.value.replace(/\\n$/, \"\").split(\"\\n\");\n            current.lines = lines;\n            if (current.added || current.removed) {\n                var _curRange;\n                // If we have previous context, start with that\n                if (!oldRangeStart) {\n                    var prev = diff[i - 1];\n                    oldRangeStart = oldLine;\n                    newRangeStart = newLine;\n                    if (prev) {\n                        curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n                        oldRangeStart -= curRange.length;\n                        newRangeStart -= curRange.length;\n                    }\n                } // Output our changes\n                (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {\n                    return (current.added ? \"+\" : \"-\") + entry;\n                }))); // Track the updated file position\n                if (current.added) newLine += lines.length;\n                else oldLine += lines.length;\n            } else {\n                // Identical context lines. Track line changes\n                if (oldRangeStart) {\n                    // Close out any changes that have been output (or join overlapping)\n                    if (lines.length <= options.context * 2 && i < diff.length - 2) {\n                        var _curRange2;\n                        // Overlapping\n                        (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n                    } else {\n                        var _curRange3;\n                        // end the range and output\n                        var contextSize = Math.min(lines.length, options.context);\n                        (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n                        var hunk = {\n                            oldStart: oldRangeStart,\n                            oldLines: oldLine - oldRangeStart + contextSize,\n                            newStart: newRangeStart,\n                            newLines: newLine - newRangeStart + contextSize,\n                            lines: curRange\n                        };\n                        if (i >= diff.length - 2 && lines.length <= options.context) {\n                            // EOF is inside this hunk\n                            var oldEOFNewline = /\\n$/.test(oldStr);\n                            var newEOFNewline = /\\n$/.test(newStr);\n                            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n                            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) // special case: old has no eol and no trailing context; no-nl can end up before adds\n                            // however, if the old file is empty, do not output the no-nl line\n                            curRange.splice(hunk.oldLines, 0, \"\\\\ No newline at end of file\");\n                            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) curRange.push(\"\\\\ No newline at end of file\");\n                        }\n                        hunks.push(hunk);\n                        oldRangeStart = 0;\n                        newRangeStart = 0;\n                        curRange = [];\n                    }\n                }\n                oldLine += lines.length;\n                newLine += lines.length;\n            }\n        };\n        for(var i = 0; i < diff.length; i++)_loop(i);\n        return {\n            oldFileName: oldFileName,\n            newFileName: newFileName,\n            oldHeader: oldHeader,\n            newHeader: newHeader,\n            hunks: hunks\n        };\n    }\n    function formatPatch(diff) {\n        if (Array.isArray(diff)) return diff.map(formatPatch).join(\"\\n\");\n        var ret = [];\n        if (diff.oldFileName == diff.newFileName) ret.push(\"Index: \" + diff.oldFileName);\n        ret.push(\"===================================================================\");\n        ret.push(\"--- \" + diff.oldFileName + (typeof diff.oldHeader === \"undefined\" ? \"\" : \"\t\" + diff.oldHeader));\n        ret.push(\"+++ \" + diff.newFileName + (typeof diff.newHeader === \"undefined\" ? \"\" : \"\t\" + diff.newHeader));\n        for(var i = 0; i < diff.hunks.length; i++){\n            var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n            // the first number is one lower than one would expect.\n            // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n            if (hunk.oldLines === 0) hunk.oldStart -= 1;\n            if (hunk.newLines === 0) hunk.newStart -= 1;\n            ret.push(\"@@ -\" + hunk.oldStart + \",\" + hunk.oldLines + \" +\" + hunk.newStart + \",\" + hunk.newLines + \" @@\");\n            ret.push.apply(ret, hunk.lines);\n        }\n        return ret.join(\"\\n\") + \"\\n\";\n    }\n    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n        return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n    }\n    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n        return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n    }\n    function arrayEqual(a, b) {\n        if (a.length !== b.length) return false;\n        return arrayStartsWith(a, b);\n    }\n    function arrayStartsWith(array, start) {\n        if (start.length > array.length) return false;\n        for(var i = 0; i < start.length; i++){\n            if (start[i] !== array[i]) return false;\n        }\n        return true;\n    }\n    function calcLineCount(hunk) {\n        var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;\n        if (oldLines !== undefined) hunk.oldLines = oldLines;\n        else delete hunk.oldLines;\n        if (newLines !== undefined) hunk.newLines = newLines;\n        else delete hunk.newLines;\n    }\n    function merge(mine, theirs, base) {\n        mine = loadPatch(mine, base);\n        theirs = loadPatch(theirs, base);\n        var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n        // Leaving sanity checks on this to the API consumer that may know more about the\n        // meaning in their own context.\n        if (mine.index || theirs.index) ret.index = mine.index || theirs.index;\n        if (mine.newFileName || theirs.newFileName) {\n            if (!fileNameChanged(mine)) {\n                // No header or no change in ours, use theirs (and ours if theirs does not exist)\n                ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n                ret.newFileName = theirs.newFileName || mine.newFileName;\n                ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n                ret.newHeader = theirs.newHeader || mine.newHeader;\n            } else if (!fileNameChanged(theirs)) {\n                // No header or no change in theirs, use ours\n                ret.oldFileName = mine.oldFileName;\n                ret.newFileName = mine.newFileName;\n                ret.oldHeader = mine.oldHeader;\n                ret.newHeader = mine.newHeader;\n            } else {\n                // Both changed... figure it out\n                ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n                ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n                ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n                ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n            }\n        }\n        ret.hunks = [];\n        var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;\n        while(mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length){\n            var mineCurrent = mine.hunks[mineIndex] || {\n                oldStart: Infinity\n            }, theirsCurrent = theirs.hunks[theirsIndex] || {\n                oldStart: Infinity\n            };\n            if (hunkBefore(mineCurrent, theirsCurrent)) {\n                // This patch does not overlap with any of the others, yay.\n                ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n                mineIndex++;\n                theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n            } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n                // This patch does not overlap with any of the others, yay.\n                ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n                theirsIndex++;\n                mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n            } else {\n                // Overlap, merge as best we can\n                var mergedHunk = {\n                    oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n                    oldLines: 0,\n                    newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n                    newLines: 0,\n                    lines: []\n                };\n                mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n                theirsIndex++;\n                mineIndex++;\n                ret.hunks.push(mergedHunk);\n            }\n        }\n        return ret;\n    }\n    function loadPatch(param, base) {\n        if (typeof param === \"string\") {\n            if (/^@@/m.test(param) || /^Index:/m.test(param)) return parsePatch(param)[0];\n            if (!base) throw new Error(\"Must provide a base reference or pass in a patch\");\n            return structuredPatch(undefined, undefined, base, param);\n        }\n        return param;\n    }\n    function fileNameChanged(patch) {\n        return patch.newFileName && patch.newFileName !== patch.oldFileName;\n    }\n    function selectField(index, mine, theirs) {\n        if (mine === theirs) return mine;\n        else {\n            index.conflict = true;\n            return {\n                mine: mine,\n                theirs: theirs\n            };\n        }\n    }\n    function hunkBefore(test, check) {\n        return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n    }\n    function cloneHunk(hunk, offset) {\n        return {\n            oldStart: hunk.oldStart,\n            oldLines: hunk.oldLines,\n            newStart: hunk.newStart + offset,\n            newLines: hunk.newLines,\n            lines: hunk.lines\n        };\n    }\n    function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n        // This will generally result in a conflicted hunk, but there are cases where the context\n        // is the only overlap where we can successfully merge the content here.\n        var mine = {\n            offset: mineOffset,\n            lines: mineLines,\n            index: 0\n        }, their = {\n            offset: theirOffset,\n            lines: theirLines,\n            index: 0\n        }; // Handle any leading content\n        insertLeading(hunk, mine, their);\n        insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n        while(mine.index < mine.lines.length && their.index < their.lines.length){\n            var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];\n            if ((mineCurrent[0] === \"-\" || mineCurrent[0] === \"+\") && (theirCurrent[0] === \"-\" || theirCurrent[0] === \"+\")) // Both modified ...\n            mutualChange(hunk, mine, their);\n            else if (mineCurrent[0] === \"+\" && theirCurrent[0] === \" \") {\n                var _hunk$lines;\n                // Mine inserted\n                (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n            } else if (theirCurrent[0] === \"+\" && mineCurrent[0] === \" \") {\n                var _hunk$lines2;\n                // Theirs inserted\n                (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n            } else if (mineCurrent[0] === \"-\" && theirCurrent[0] === \" \") // Mine removed or edited\n            removal(hunk, mine, their);\n            else if (theirCurrent[0] === \"-\" && mineCurrent[0] === \" \") // Their removed or edited\n            removal(hunk, their, mine, true);\n            else if (mineCurrent === theirCurrent) {\n                // Context identity\n                hunk.lines.push(mineCurrent);\n                mine.index++;\n                their.index++;\n            } else // Context mismatch\n            conflict(hunk, collectChange(mine), collectChange(their));\n        } // Now push anything that may be remaining\n        insertTrailing(hunk, mine);\n        insertTrailing(hunk, their);\n        calcLineCount(hunk);\n    }\n    function mutualChange(hunk, mine, their) {\n        var myChanges = collectChange(mine), theirChanges = collectChange(their);\n        if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n            // Special case for remove changes that are supersets of one another\n            if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n                var _hunk$lines3;\n                (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n                return;\n            } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n                var _hunk$lines4;\n                (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n                return;\n            }\n        } else if (arrayEqual(myChanges, theirChanges)) {\n            var _hunk$lines5;\n            (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n            return;\n        }\n        conflict(hunk, myChanges, theirChanges);\n    }\n    function removal(hunk, mine, their, swap) {\n        var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);\n        if (theirChanges.merged) {\n            var _hunk$lines6;\n            (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n        } else conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n    function conflict(hunk, mine, their) {\n        hunk.conflict = true;\n        hunk.lines.push({\n            conflict: true,\n            mine: mine,\n            theirs: their\n        });\n    }\n    function insertLeading(hunk, insert, their) {\n        while(insert.offset < their.offset && insert.index < insert.lines.length){\n            var line = insert.lines[insert.index++];\n            hunk.lines.push(line);\n            insert.offset++;\n        }\n    }\n    function insertTrailing(hunk, insert) {\n        while(insert.index < insert.lines.length){\n            var line = insert.lines[insert.index++];\n            hunk.lines.push(line);\n        }\n    }\n    function collectChange(state) {\n        var ret = [], operation = state.lines[state.index][0];\n        while(state.index < state.lines.length){\n            var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n            if (operation === \"-\" && line[0] === \"+\") operation = \"+\";\n            if (operation === line[0]) {\n                ret.push(line);\n                state.index++;\n            } else break;\n        }\n        return ret;\n    }\n    function collectContext(state, matchChanges) {\n        var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;\n        while(matchIndex < matchChanges.length && state.index < state.lines.length){\n            var change = state.lines[state.index], match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n            if (match[0] === \"+\") break;\n            contextChanges = contextChanges || change[0] !== \" \";\n            merged.push(match);\n            matchIndex++; // Consume any additions in the other block as a conflict to attempt\n            // to pull in the remaining context after this\n            if (change[0] === \"+\") {\n                conflicted = true;\n                while(change[0] === \"+\"){\n                    changes.push(change);\n                    change = state.lines[++state.index];\n                }\n            }\n            if (match.substr(1) === change.substr(1)) {\n                changes.push(change);\n                state.index++;\n            } else conflicted = true;\n        }\n        if ((matchChanges[matchIndex] || \"\")[0] === \"+\" && contextChanges) conflicted = true;\n        if (conflicted) return changes;\n        while(matchIndex < matchChanges.length)merged.push(matchChanges[matchIndex++]);\n        return {\n            merged: merged,\n            changes: changes\n        };\n    }\n    function allRemoves(changes) {\n        return changes.reduce(function(prev, change) {\n            return prev && change[0] === \"-\";\n        }, true);\n    }\n    function skipRemoveSuperset(state, removeChanges, delta) {\n        for(var i = 0; i < delta; i++){\n            var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n            if (state.lines[state.index + i] !== \" \" + changeContent) return false;\n        }\n        state.index += delta;\n        return true;\n    }\n    function calcOldNewLineCount(lines) {\n        var oldLines = 0;\n        var newLines = 0;\n        lines.forEach(function(line) {\n            if (typeof line !== \"string\") {\n                var myCount = calcOldNewLineCount(line.mine);\n                var theirCount = calcOldNewLineCount(line.theirs);\n                if (oldLines !== undefined) {\n                    if (myCount.oldLines === theirCount.oldLines) oldLines += myCount.oldLines;\n                    else oldLines = undefined;\n                }\n                if (newLines !== undefined) {\n                    if (myCount.newLines === theirCount.newLines) newLines += myCount.newLines;\n                    else newLines = undefined;\n                }\n            } else {\n                if (newLines !== undefined && (line[0] === \"+\" || line[0] === \" \")) newLines++;\n                if (oldLines !== undefined && (line[0] === \"-\" || line[0] === \" \")) oldLines++;\n            }\n        });\n        return {\n            oldLines: oldLines,\n            newLines: newLines\n        };\n    }\n    function reversePatch(structuredPatch) {\n        if (Array.isArray(structuredPatch)) return structuredPatch.map(reversePatch).reverse();\n        return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {\n            oldFileName: structuredPatch.newFileName,\n            oldHeader: structuredPatch.newHeader,\n            newFileName: structuredPatch.oldFileName,\n            newHeader: structuredPatch.oldHeader,\n            hunks: structuredPatch.hunks.map(function(hunk) {\n                return {\n                    oldLines: hunk.newLines,\n                    oldStart: hunk.newStart,\n                    newLines: hunk.oldLines,\n                    newStart: hunk.oldStart,\n                    linedelimiters: hunk.linedelimiters,\n                    lines: hunk.lines.map(function(l) {\n                        if (l.startsWith(\"-\")) return \"+\".concat(l.slice(1));\n                        if (l.startsWith(\"+\")) return \"-\".concat(l.slice(1));\n                        return l;\n                    })\n                };\n            })\n        });\n    }\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n    function convertChangesToDMP(changes) {\n        var ret = [], change, operation;\n        for(var i = 0; i < changes.length; i++){\n            change = changes[i];\n            if (change.added) operation = 1;\n            else if (change.removed) operation = -1;\n            else operation = 0;\n            ret.push([\n                operation,\n                change.value\n            ]);\n        }\n        return ret;\n    }\n    function convertChangesToXML(changes) {\n        var ret = [];\n        for(var i = 0; i < changes.length; i++){\n            var change = changes[i];\n            if (change.added) ret.push(\"<ins>\");\n            else if (change.removed) ret.push(\"<del>\");\n            ret.push(escapeHTML(change.value));\n            if (change.added) ret.push(\"</ins>\");\n            else if (change.removed) ret.push(\"</del>\");\n        }\n        return ret.join(\"\");\n    }\n    function escapeHTML(s) {\n        var n = s;\n        n = n.replace(/&/g, \"&amp;\");\n        n = n.replace(/</g, \"&lt;\");\n        n = n.replace(/>/g, \"&gt;\");\n        n = n.replace(/\"/g, \"&quot;\");\n        return n;\n    }\n    exports1.Diff = Diff;\n    exports1.applyPatch = applyPatch;\n    exports1.applyPatches = applyPatches;\n    exports1.canonicalize = canonicalize;\n    exports1.convertChangesToDMP = convertChangesToDMP;\n    exports1.convertChangesToXML = convertChangesToXML;\n    exports1.createPatch = createPatch;\n    exports1.createTwoFilesPatch = createTwoFilesPatch;\n    exports1.diffArrays = diffArrays;\n    exports1.diffChars = diffChars;\n    exports1.diffCss = diffCss;\n    exports1.diffJson = diffJson;\n    exports1.diffLines = diffLines;\n    exports1.diffSentences = diffSentences;\n    exports1.diffTrimmedLines = diffTrimmedLines;\n    exports1.diffWords = diffWords;\n    exports1.diffWordsWithSpace = diffWordsWithSpace;\n    exports1.formatPatch = formatPatch;\n    exports1.merge = merge;\n    exports1.parsePatch = parsePatch;\n    exports1.reversePatch = reversePatch;\n    exports1.structuredPatch = structuredPatch;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n});\n\n\nconsole.log(\"Hello world!\");\ndocument.getElementById(\"compare\").addEventListener(\"click\", function() {\n    var text1 = document.getElementById(\"text1\").value;\n    var text2 = document.getElementById(\"text2\").value;\n    var diff = (0, $b949b6fb3549d721$exports.diffWords)(text1, text2);\n    var display = diff.map((part)=>{\n        const color = part.added ? \"green\" : part.removed ? \"red\" : \"grey\";\n        return `<span style=\"color:${color};\">${part.value}</span>`;\n    }).join(\"\");\n    document.getElementById(\"result\").innerHTML = display;\n});\ndocument.getElementById(\"copyButton\").addEventListener(\"click\", function() {\n    // Get the HTML content from the result container\n    var htmlContent = document.getElementById(\"result\").innerHTML;\n    // Copy the HTML to the clipboard\n    if (!navigator.clipboard) // Clipboard API not available\n    return;\n    navigator.clipboard.write([\n        new ClipboardItem({\n            \"text/html\": new Blob([\n                htmlContent\n            ], {\n                type: \"text/html\"\n            })\n        })\n    ]).then(function() {\n        console.log(\"Copying to clipboard was successful!\");\n        // Optionally, alert the user that the copy was successful\n        alert(\"Results copied to clipboard!\");\n    }, function(err) {\n        console.error(\"Could not copy text: \", err);\n        // Optionally, alert the user that the copy failed\n        alert(\"Failed to copy results. Please try again.\");\n    });\n});\n\n\n//# sourceMappingURL=index.6e6c7e4e.js.map\n","console.log('Hello world!');\n\nimport { diffWords } from 'diff';\n\ndocument.getElementById('compare').addEventListener('click', function() {\n    var text1 = document.getElementById('text1').value;\n    var text2 = document.getElementById('text2').value;\n    var diff = diffWords(text1, text2);\n\n    var display = diff.map(part => {\n        const color = part.added ? 'green' :\n                      part.removed ? 'red' : 'grey';\n        return `<span style=\"color:${color};\">${part.value}</span>`;\n    }).join('');\n\n    document.getElementById('result').innerHTML = display;\n});\n\n\n\ndocument.getElementById('copyButton').addEventListener('click', function() {\n  // Get the HTML content from the result container\n  var htmlContent = document.getElementById('result').innerHTML;\n\n  // Copy the HTML to the clipboard\n  if (!navigator.clipboard) {\n    // Clipboard API not available\n    return;\n  }\n\n  navigator.clipboard.write([\n    new ClipboardItem({\n      \"text/html\": new Blob([htmlContent], { type: \"text/html\" })\n    })\n  ]).then(function() {\n    console.log('Copying to clipboard was successful!');\n    // Optionally, alert the user that the copy was successful\n    alert('Results copied to clipboard!');\n  }, function(err) {\n    console.error('Could not copy text: ', err);\n    // Optionally, alert the user that the copy failed\n    alert('Failed to copy results. Please try again.');\n  });\n});","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.Diff = {}));\n}(this, (function (exports) { 'use strict';\n\n  function Diff() {}\n  Diff.prototype = {\n    diff: function diff(oldString, newString) {\n      var _options$timeout;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = options.callback;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      this.options = options;\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function () {\n            callback(undefined, value);\n          }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      } // Allow subclasses to massage the input prior to running\n\n\n      oldString = this.castInput(oldString);\n      newString = this.castInput(newString);\n      oldString = this.removeEmpty(this.tokenize(oldString));\n      newString = this.removeEmpty(this.tokenize(newString));\n      var newLen = newString.length,\n          oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n\n      if (options.maxEditLength) {\n        maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n      }\n\n      var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n      var abortAfterTimestamp = Date.now() + maxExecutionTime;\n      var bestPath = [{\n        oldPos: -1,\n        lastComponent: undefined\n      }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n      var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n      if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n        // Identity per the equality and tokenizer\n        return done([{\n          value: this.join(newString),\n          count: newString.length\n        }]);\n      } // Once we hit the right edge of the edit graph on some diagonal k, we can\n      // definitely reach the end of the edit graph in no more than k edits, so\n      // there's no point in considering any moves to diagonal k+1 any more (from\n      // which we're guaranteed to need at least k+1 more edits).\n      // Similarly, once we've reached the bottom of the edit graph, there's no\n      // point considering moves to lower diagonals.\n      // We record this fact by setting minDiagonalToConsider and\n      // maxDiagonalToConsider to some finite value once we've hit the edge of\n      // the edit graph.\n      // This optimization is not faithful to the original algorithm presented in\n      // Myers's paper, which instead pointlessly extends D-paths off the end of\n      // the edit graph - see page 7 of Myers's paper which notes this point\n      // explicitly and illustrates it with a diagram. This has major performance\n      // implications for some common scenarios. For instance, to compute a diff\n      // where the new text simply appends d characters on the end of the\n      // original text of length n, the true Myers algorithm will take O(n+d^2)\n      // time while this optimization needs only O(n+d) time.\n\n\n      var minDiagonalToConsider = -Infinity,\n          maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.\n\n      function execEditLength() {\n        for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n          var basePath = void 0;\n          var removePath = bestPath[diagonalPath - 1],\n              addPath = bestPath[diagonalPath + 1];\n\n          if (removePath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = false;\n\n          if (addPath) {\n            // what newPos will be after we do an insertion:\n            var addPathNewPos = addPath.oldPos - diagonalPath;\n            canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n          }\n\n          var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          } // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the old string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n          // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n          //       and prefer to order removals before insertions.\n\n\n          if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {\n            basePath = self.addToPath(addPath, true, undefined, 0);\n          } else {\n            basePath = self.addToPath(removePath, undefined, true, 1);\n          }\n\n          newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n          if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // If we have hit the end of both strings, then we are done\n            return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n          } else {\n            bestPath[diagonalPath] = basePath;\n\n            if (basePath.oldPos + 1 >= oldLen) {\n              maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n            }\n\n            if (newPos + 1 >= newLen) {\n              minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n            }\n          }\n        }\n\n        editLength++;\n      } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced, or until the edit length exceeds options.maxEditLength (if given),\n      // in which case it will return undefined.\n\n\n      if (callback) {\n        (function exec() {\n          setTimeout(function () {\n            if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        })();\n      } else {\n        while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n          var ret = execEditLength();\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n    addToPath: function addToPath(path, added, removed, oldPosInc) {\n      var last = path.lastComponent;\n\n      if (last && last.added === added && last.removed === removed) {\n        return {\n          oldPos: path.oldPos + oldPosInc,\n          lastComponent: {\n            count: last.count + 1,\n            added: added,\n            removed: removed,\n            previousComponent: last.previousComponent\n          }\n        };\n      } else {\n        return {\n          oldPos: path.oldPos + oldPosInc,\n          lastComponent: {\n            count: 1,\n            added: added,\n            removed: removed,\n            previousComponent: last\n          }\n        };\n      }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          oldPos = basePath.oldPos,\n          newPos = oldPos - diagonalPath,\n          commonCount = 0;\n\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.lastComponent = {\n          count: commonCount,\n          previousComponent: basePath.lastComponent\n        };\n      }\n\n      basePath.oldPos = oldPos;\n      return newPos;\n    },\n    equals: function equals(left, right) {\n      if (this.options.comparator) {\n        return this.options.comparator(left, right);\n      } else {\n        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n      }\n    },\n    removeEmpty: function removeEmpty(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n\n      return ret;\n    },\n    castInput: function castInput(value) {\n      return value;\n    },\n    tokenize: function tokenize(value) {\n      return value.split('');\n    },\n    join: function join(chars) {\n      return chars.join('');\n    }\n  };\n\n  function buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n    // First we convert our linked list of components in reverse order to an\n    // array in the right order:\n    var components = [];\n    var nextComponent;\n\n    while (lastComponent) {\n      components.push(lastComponent);\n      nextComponent = lastComponent.previousComponent;\n      delete lastComponent.previousComponent;\n      lastComponent = nextComponent;\n    }\n\n    components.reverse();\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = diff.join(value);\n        } else {\n          component.value = diff.join(newString.slice(newPos, newPos + component.count));\n        }\n\n        newPos += component.count; // Common case\n\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n\n\n    var finalComponent = components[componentLen - 1];\n\n    if (componentLen > 1 && typeof finalComponent.value === 'string' && (finalComponent.added || finalComponent.removed) && diff.equals('', finalComponent.value)) {\n      components[componentLen - 2].value += finalComponent.value;\n      components.pop();\n    }\n\n    return components;\n  }\n\n  var characterDiff = new Diff();\n  function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n  }\n\n  function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n      defaults.callback = options;\n    } else if (options) {\n      for (var name in options) {\n        /* istanbul ignore else */\n        if (options.hasOwnProperty(name)) {\n          defaults[name] = options[name];\n        }\n      }\n    }\n\n    return defaults;\n  }\n\n  //\n  // Ranges and exceptions:\n  // Latin-1 Supplement, 0080–00FF\n  //  - U+00D7  × Multiplication sign\n  //  - U+00F7  ÷ Division sign\n  // Latin Extended-A, 0100–017F\n  // Latin Extended-B, 0180–024F\n  // IPA Extensions, 0250–02AF\n  // Spacing Modifier Letters, 02B0–02FF\n  //  - U+02C7  ˇ &#711;  Caron\n  //  - U+02D8  ˘ &#728;  Breve\n  //  - U+02D9  ˙ &#729;  Dot Above\n  //  - U+02DA  ˚ &#730;  Ring Above\n  //  - U+02DB  ˛ &#731;  Ogonek\n  //  - U+02DC  ˜ &#732;  Small Tilde\n  //  - U+02DD  ˝ &#733;  Double Acute Accent\n  // Latin Extended Additional, 1E00–1EFF\n\n  var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n  var reWhitespace = /\\S/;\n  var wordDiff = new Diff();\n\n  wordDiff.equals = function (left, right) {\n    if (this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n  };\n\n  wordDiff.tokenize = function (value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n    for (var i = 0; i < tokens.length - 1; i++) {\n      // If we have an empty string in the next field and we have only word chars before and after, merge\n      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n        tokens[i] += tokens[i + 2];\n        tokens.splice(i + 1, 2);\n        i--;\n      }\n    }\n\n    return tokens;\n  };\n\n  function diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n      ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n  function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  var lineDiff = new Diff();\n\n  lineDiff.tokenize = function (value) {\n    if (this.options.stripTrailingCr) {\n      // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n      value = value.replace(/\\r\\n/g, '\\n');\n    }\n\n    var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n\n\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2 && !this.options.newlineIsToken) {\n        retLines[retLines.length - 1] += line;\n      } else {\n        if (this.options.ignoreWhitespace) {\n          line = line.trim();\n        }\n\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  function diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n  }\n  function diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n      ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n  }\n\n  var sentenceDiff = new Diff();\n\n  sentenceDiff.tokenize = function (value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n  };\n\n  function diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n  }\n\n  var cssDiff = new Diff();\n\n  cssDiff.tokenize = function (value) {\n    return value.split(/([{}:;,]|\\s+)/);\n  };\n\n  function diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var objectPrototypeToString = Object.prototype.toString;\n  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n  jsonDiff.useLongestToken = true;\n  jsonDiff.tokenize = lineDiff.tokenize;\n\n  jsonDiff.castInput = function (value) {\n    var _this$options = this.options,\n        undefinedReplacement = _this$options.undefinedReplacement,\n        _this$options$stringi = _this$options.stringifyReplacer,\n        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n  };\n\n  jsonDiff.equals = function (left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  function diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n  } // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n  function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    if (replacer) {\n      obj = replacer(key, obj);\n    }\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n      return canonicalizedObj;\n    }\n\n    if (obj && obj.toJSON) {\n      obj = obj.toJSON();\n    }\n\n    if (_typeof(obj) === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n\n      var sortedKeys = [],\n          _key;\n\n      for (_key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(_key)) {\n          sortedKeys.push(_key);\n        }\n      }\n\n      sortedKeys.sort();\n\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        _key = sortedKeys[i];\n        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n\n    return canonicalizedObj;\n  }\n\n  var arrayDiff = new Diff();\n\n  arrayDiff.tokenize = function (value) {\n    return value.slice();\n  };\n\n  arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n    return value;\n  };\n\n  function diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n  }\n\n  function parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        list = [],\n        i = 0;\n\n    function parseIndex() {\n      var index = {};\n      list.push(index); // Parse diff metadata\n\n      while (i < diffstr.length) {\n        var line = diffstr[i]; // File header found, end parsing diff metadata\n\n        if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n          break;\n        } // Diff index\n\n\n        var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n        if (header) {\n          index.index = header[1];\n        }\n\n        i++;\n      } // Parse file headers if they are defined. Unified diff requires them, but\n      // there's no technical issues to have an isolated hunk without file header\n\n\n      parseFileHeader(index);\n      parseFileHeader(index); // Parse hunks\n\n      index.hunks = [];\n\n      while (i < diffstr.length) {\n        var _line = diffstr[i];\n\n        if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n          break;\n        } else if (/^@@/.test(_line)) {\n          index.hunks.push(parseHunk());\n        } else if (_line && options.strict) {\n          // Ignore unexpected content unless in strict mode\n          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n        } else {\n          i++;\n        }\n      }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n\n\n    function parseFileHeader(index) {\n      var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n      if (fileHeader) {\n        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n        var data = fileHeader[2].split('\\t', 2);\n        var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n        if (/^\".*\"$/.test(fileName)) {\n          fileName = fileName.substr(1, fileName.length - 2);\n        }\n\n        index[keyPrefix + 'FileName'] = fileName;\n        index[keyPrefix + 'Header'] = (data[1] || '').trim();\n        i++;\n      }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n\n\n    function parseHunk() {\n      var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n      var hunk = {\n        oldStart: +chunkHeader[1],\n        oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n        newStart: +chunkHeader[3],\n        newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n        lines: [],\n        linedelimiters: []\n      }; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart += 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart += 1;\n      }\n\n      var addCount = 0,\n          removeCount = 0;\n\n      for (; i < diffstr.length; i++) {\n        // Lines starting with '---' could be mistaken for the \"remove line\" operation\n        // But they could be the header for the next file. Therefore prune such cases out.\n        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n        }\n\n        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n          hunk.lines.push(diffstr[i]);\n          hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n          if (operation === '+') {\n            addCount++;\n          } else if (operation === '-') {\n            removeCount++;\n          } else if (operation === ' ') {\n            addCount++;\n            removeCount++;\n          }\n        } else {\n          break;\n        }\n      } // Handle the empty block count case\n\n\n      if (!addCount && hunk.newLines === 1) {\n        hunk.newLines = 0;\n      }\n\n      if (!removeCount && hunk.oldLines === 1) {\n        hunk.oldLines = 0;\n      } // Perform optional sanity checking\n\n\n      if (options.strict) {\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n      }\n\n      return hunk;\n    }\n\n    while (i < diffstr.length) {\n      parseIndex();\n    }\n\n    return list;\n  }\n\n  // Iterator that traverses in the range of [min, max], stepping\n  // by distance from a given start position. I.e. for [0, 4], with\n  // start of 2, this will iterate 2, 3, 1, 4, 0.\n  function distanceIterator (start, minLine, maxLine) {\n    var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n    return function iterator() {\n      if (wantForward && !forwardExhausted) {\n        if (backwardExhausted) {\n          localOffset++;\n        } else {\n          wantForward = false;\n        } // Check if trying to fit beyond text length, and if not, check it fits\n        // after offset location (or desired location on first iteration)\n\n\n        if (start + localOffset <= maxLine) {\n          return localOffset;\n        }\n\n        forwardExhausted = true;\n      }\n\n      if (!backwardExhausted) {\n        if (!forwardExhausted) {\n          wantForward = true;\n        } // Check if trying to fit before text beginning, and if not, check it fits\n        // before offset location\n\n\n        if (minLine <= start - localOffset) {\n          return -localOffset++;\n        }\n\n        backwardExhausted = true;\n        return iterator();\n      } // We tried to fit hunk before text beginning and beyond text length, then\n      // hunk can't fit on the text. Return undefined\n\n    };\n  }\n\n  function applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    if (Array.isArray(uniDiff)) {\n      if (uniDiff.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n      }\n\n      uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n\n\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n        errorCount = 0,\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0,\n        offset = 0,\n        removeEOFNL,\n        addEOFNL;\n    /**\n     * Checks if the hunk exactly fits on the provided location\n     */\n\n\n    function hunkFits(hunk, toPos) {\n      for (var j = 0; j < hunk.lines.length; j++) {\n        var line = hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line;\n\n        if (operation === ' ' || operation === '-') {\n          // Context sanity check\n          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n            errorCount++;\n\n            if (errorCount > fuzzFactor) {\n              return false;\n            }\n          }\n\n          toPos++;\n        }\n      }\n\n      return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n\n\n    for (var i = 0; i < hunks.length; i++) {\n      var hunk = hunks[i],\n          maxLine = lines.length - hunk.oldLines,\n          localOffset = 0,\n          toPos = offset + hunk.oldStart - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n\n      for (; localOffset !== undefined; localOffset = iterator()) {\n        if (hunkFits(hunk, toPos + localOffset)) {\n          hunk.offset = offset += localOffset;\n          break;\n        }\n      }\n\n      if (localOffset === undefined) {\n        return false;\n      } // Set lower text limit to end of the current hunk, so next ones don't try\n      // to fit over already patched text\n\n\n      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n\n\n    var diffOffset = 0;\n\n    for (var _i = 0; _i < hunks.length; _i++) {\n      var _hunk = hunks[_i],\n          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n      diffOffset += _hunk.newLines - _hunk.oldLines;\n\n      for (var j = 0; j < _hunk.lines.length; j++) {\n        var line = _hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line,\n            delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || '\\n';\n\n        if (operation === ' ') {\n          _toPos++;\n        } else if (operation === '-') {\n          lines.splice(_toPos, 1);\n          delimiters.splice(_toPos, 1);\n          /* istanbul ignore else */\n        } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n    } // Handle EOFNL insertion/removal\n\n\n    if (removeEOFNL) {\n      while (!lines[lines.length - 1]) {\n        lines.pop();\n        delimiters.pop();\n      }\n    } else if (addEOFNL) {\n      lines.push('');\n      delimiters.push('\\n');\n    }\n\n    for (var _k = 0; _k < lines.length - 1; _k++) {\n      lines[_k] = lines[_k] + delimiters[_k];\n    }\n\n    return lines.join('');\n  } // Wrapper that supports multiple file patches via callbacks.\n\n  function applyPatches(uniDiff, options) {\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    var currentIndex = 0;\n\n    function processIndex() {\n      var index = uniDiff[currentIndex++];\n\n      if (!index) {\n        return options.complete();\n      }\n\n      options.loadFile(index, function (err, data) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        var updatedContent = applyPatch(data, index, options);\n        options.patched(index, updatedContent, function (err) {\n          if (err) {\n            return options.complete(err);\n          }\n\n          processIndex();\n        });\n      });\n    }\n\n    processIndex();\n  }\n\n  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options.context === 'undefined') {\n      options.context = 4;\n    }\n\n    var diff = diffLines(oldStr, newStr, options);\n\n    if (!diff) {\n      return;\n    }\n\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n\n    var hunks = [];\n    var oldRangeStart = 0,\n        newRangeStart = 0,\n        curRange = [],\n        oldLine = 1,\n        newLine = 1;\n\n    var _loop = function _loop(i) {\n      var current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        var _curRange;\n\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        } // Output our changes\n\n\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        }))); // Track the updated file position\n\n\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2;\n\n            // Overlapping\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3;\n\n            // end the range and output\n            var contextSize = Math.min(lines.length, options.context);\n\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n            var hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n\n            if (i >= diff.length - 2 && lines.length <= options.context) {\n              // EOF is inside this hunk\n              var oldEOFNewline = /\\n$/.test(oldStr);\n              var newEOFNewline = /\\n$/.test(newStr);\n              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n              if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                // special case: old has no eol and no trailing context; no-nl can end up before adds\n                // however, if the old file is empty, do not output the no-nl line\n                curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n              }\n\n              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                curRange.push('\\\\ No newline at end of file');\n              }\n            }\n\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n\n    for (var i = 0; i < diff.length; i++) {\n      _loop(i);\n    }\n\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n  function formatPatch(diff) {\n    if (Array.isArray(diff)) {\n      return diff.map(formatPatch).join('\\n');\n    }\n\n    var ret = [];\n\n    if (diff.oldFileName == diff.newFileName) {\n      ret.push('Index: ' + diff.oldFileName);\n    }\n\n    ret.push('===================================================================');\n    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n    for (var i = 0; i < diff.hunks.length; i++) {\n      var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart -= 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart -= 1;\n      }\n\n      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n      ret.push.apply(ret, hunk.lines);\n    }\n\n    return ret.join('\\n') + '\\n';\n  }\n  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n  }\n  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n  }\n\n  function arrayEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return arrayStartsWith(a, b);\n  }\n  function arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n      return false;\n    }\n\n    for (var i = 0; i < start.length; i++) {\n      if (start[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n\n    if (oldLines !== undefined) {\n      hunk.oldLines = oldLines;\n    } else {\n      delete hunk.oldLines;\n    }\n\n    if (newLines !== undefined) {\n      hunk.newLines = newLines;\n    } else {\n      delete hunk.newLines;\n    }\n  }\n  function merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n\n    if (mine.index || theirs.index) {\n      ret.index = mine.index || theirs.index;\n    }\n\n    if (mine.newFileName || theirs.newFileName) {\n      if (!fileNameChanged(mine)) {\n        // No header or no change in ours, use theirs (and ours if theirs does not exist)\n        ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n        ret.newFileName = theirs.newFileName || mine.newFileName;\n        ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n        ret.newHeader = theirs.newHeader || mine.newHeader;\n      } else if (!fileNameChanged(theirs)) {\n        // No header or no change in theirs, use ours\n        ret.oldFileName = mine.oldFileName;\n        ret.newFileName = mine.newFileName;\n        ret.oldHeader = mine.oldHeader;\n        ret.newHeader = mine.newHeader;\n      } else {\n        // Both changed... figure it out\n        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n      }\n    }\n\n    ret.hunks = [];\n    var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n\n    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n      var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n\n      if (hunkBefore(mineCurrent, theirsCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n        mineIndex++;\n        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n      } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n        theirsIndex++;\n        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n      } else {\n        // Overlap, merge as best we can\n        var mergedHunk = {\n          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n          oldLines: 0,\n          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n          newLines: 0,\n          lines: []\n        };\n        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n        theirsIndex++;\n        mineIndex++;\n        ret.hunks.push(mergedHunk);\n      }\n    }\n\n    return ret;\n  }\n\n  function loadPatch(param, base) {\n    if (typeof param === 'string') {\n      if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n        return parsePatch(param)[0];\n      }\n\n      if (!base) {\n        throw new Error('Must provide a base reference or pass in a patch');\n      }\n\n      return structuredPatch(undefined, undefined, base, param);\n    }\n\n    return param;\n  }\n\n  function fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n  }\n\n  function selectField(index, mine, theirs) {\n    if (mine === theirs) {\n      return mine;\n    } else {\n      index.conflict = true;\n      return {\n        mine: mine,\n        theirs: theirs\n      };\n    }\n  }\n\n  function hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n  }\n\n  function cloneHunk(hunk, offset) {\n    return {\n      oldStart: hunk.oldStart,\n      oldLines: hunk.oldLines,\n      newStart: hunk.newStart + offset,\n      newLines: hunk.newLines,\n      lines: hunk.lines\n    };\n  }\n\n  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n        their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n    while (mine.index < mine.lines.length && their.index < their.lines.length) {\n      var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n\n      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n        // Both modified ...\n        mutualChange(hunk, mine, their);\n      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n        var _hunk$lines;\n\n        // Mine inserted\n        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n        var _hunk$lines2;\n\n        // Theirs inserted\n        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n        // Mine removed or edited\n        removal(hunk, mine, their);\n      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n        // Their removed or edited\n        removal(hunk, their, mine, true);\n      } else if (mineCurrent === theirCurrent) {\n        // Context identity\n        hunk.lines.push(mineCurrent);\n        mine.index++;\n        their.index++;\n      } else {\n        // Context mismatch\n        conflict(hunk, collectChange(mine), collectChange(their));\n      }\n    } // Now push anything that may be remaining\n\n\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n  }\n\n  function mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n      // Special case for remove changes that are supersets of one another\n      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n        var _hunk$lines3;\n\n        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n        return;\n      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n        var _hunk$lines4;\n\n        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n        return;\n      }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n      var _hunk$lines5;\n\n      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n      return;\n    }\n\n    conflict(hunk, myChanges, theirChanges);\n  }\n\n  function removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n\n    if (theirChanges.merged) {\n      var _hunk$lines6;\n\n      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n  }\n\n  function conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n      conflict: true,\n      mine: mine,\n      theirs: their\n    });\n  }\n\n  function insertLeading(hunk, insert, their) {\n    while (insert.offset < their.offset && insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n      insert.offset++;\n    }\n  }\n\n  function insertTrailing(hunk, insert) {\n    while (insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n    }\n  }\n\n  function collectChange(state) {\n    var ret = [],\n        operation = state.lines[state.index][0];\n\n    while (state.index < state.lines.length) {\n      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n      if (operation === '-' && line[0] === '+') {\n        operation = '+';\n      }\n\n      if (operation === line[0]) {\n        ret.push(line);\n        state.index++;\n      } else {\n        break;\n      }\n    }\n\n    return ret;\n  }\n\n  function collectContext(state, matchChanges) {\n    var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n\n    while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n      var change = state.lines[state.index],\n          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n      if (match[0] === '+') {\n        break;\n      }\n\n      contextChanges = contextChanges || change[0] !== ' ';\n      merged.push(match);\n      matchIndex++; // Consume any additions in the other block as a conflict to attempt\n      // to pull in the remaining context after this\n\n      if (change[0] === '+') {\n        conflicted = true;\n\n        while (change[0] === '+') {\n          changes.push(change);\n          change = state.lines[++state.index];\n        }\n      }\n\n      if (match.substr(1) === change.substr(1)) {\n        changes.push(change);\n        state.index++;\n      } else {\n        conflicted = true;\n      }\n    }\n\n    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n      conflicted = true;\n    }\n\n    if (conflicted) {\n      return changes;\n    }\n\n    while (matchIndex < matchChanges.length) {\n      merged.push(matchChanges[matchIndex++]);\n    }\n\n    return {\n      merged: merged,\n      changes: changes\n    };\n  }\n\n  function allRemoves(changes) {\n    return changes.reduce(function (prev, change) {\n      return prev && change[0] === '-';\n    }, true);\n  }\n\n  function skipRemoveSuperset(state, removeChanges, delta) {\n    for (var i = 0; i < delta; i++) {\n      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n      if (state.lines[state.index + i] !== ' ' + changeContent) {\n        return false;\n      }\n    }\n\n    state.index += delta;\n    return true;\n  }\n\n  function calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function (line) {\n      if (typeof line !== 'string') {\n        var myCount = calcOldNewLineCount(line.mine);\n        var theirCount = calcOldNewLineCount(line.theirs);\n\n        if (oldLines !== undefined) {\n          if (myCount.oldLines === theirCount.oldLines) {\n            oldLines += myCount.oldLines;\n          } else {\n            oldLines = undefined;\n          }\n        }\n\n        if (newLines !== undefined) {\n          if (myCount.newLines === theirCount.newLines) {\n            newLines += myCount.newLines;\n          } else {\n            newLines = undefined;\n          }\n        }\n      } else {\n        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n          newLines++;\n        }\n\n        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n          oldLines++;\n        }\n      }\n    });\n    return {\n      oldLines: oldLines,\n      newLines: newLines\n    };\n  }\n\n  function reversePatch(structuredPatch) {\n    if (Array.isArray(structuredPatch)) {\n      return structuredPatch.map(reversePatch).reverse();\n    }\n\n    return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {\n      oldFileName: structuredPatch.newFileName,\n      oldHeader: structuredPatch.newHeader,\n      newFileName: structuredPatch.oldFileName,\n      newHeader: structuredPatch.oldHeader,\n      hunks: structuredPatch.hunks.map(function (hunk) {\n        return {\n          oldLines: hunk.newLines,\n          oldStart: hunk.newStart,\n          newLines: hunk.oldLines,\n          newStart: hunk.oldStart,\n          linedelimiters: hunk.linedelimiters,\n          lines: hunk.lines.map(function (l) {\n            if (l.startsWith('-')) {\n              return \"+\".concat(l.slice(1));\n            }\n\n            if (l.startsWith('+')) {\n              return \"-\".concat(l.slice(1));\n            }\n\n            return l;\n          })\n        };\n      })\n    });\n  }\n\n  // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n  function convertChangesToDMP(changes) {\n    var ret = [],\n        change,\n        operation;\n\n    for (var i = 0; i < changes.length; i++) {\n      change = changes[i];\n\n      if (change.added) {\n        operation = 1;\n      } else if (change.removed) {\n        operation = -1;\n      } else {\n        operation = 0;\n      }\n\n      ret.push([operation, change.value]);\n    }\n\n    return ret;\n  }\n\n  function convertChangesToXML(changes) {\n    var ret = [];\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (change.added) {\n        ret.push('<ins>');\n      } else if (change.removed) {\n        ret.push('<del>');\n      }\n\n      ret.push(escapeHTML(change.value));\n\n      if (change.added) {\n        ret.push('</ins>');\n      } else if (change.removed) {\n        ret.push('</del>');\n      }\n    }\n\n    return ret.join('');\n  }\n\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n    return n;\n  }\n\n  exports.Diff = Diff;\n  exports.applyPatch = applyPatch;\n  exports.applyPatches = applyPatches;\n  exports.canonicalize = canonicalize;\n  exports.convertChangesToDMP = convertChangesToDMP;\n  exports.convertChangesToXML = convertChangesToXML;\n  exports.createPatch = createPatch;\n  exports.createTwoFilesPatch = createTwoFilesPatch;\n  exports.diffArrays = diffArrays;\n  exports.diffChars = diffChars;\n  exports.diffCss = diffCss;\n  exports.diffJson = diffJson;\n  exports.diffLines = diffLines;\n  exports.diffSentences = diffSentences;\n  exports.diffTrimmedLines = diffTrimmedLines;\n  exports.diffWords = diffWords;\n  exports.diffWordsWithSpace = diffWordsWithSpace;\n  exports.formatPatch = formatPatch;\n  exports.merge = merge;\n  exports.parsePatch = parsePatch;\n  exports.reversePatch = reversePatch;\n  exports.structuredPatch = structuredPatch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"names":["$b949b6fb3549d721$exports","factory","exports1","Diff","prototype","diff","oldString","newString","_options$timeout","options","arguments","length","undefined","callback","self","done","value","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","Math","min","maxExecutionTime","timeout","Infinity","abortAfterTimestamp","Date","now","bestPath","oldPos","lastComponent","newPos","extractCommon","join","count","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","max","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","addToPath","buildValues","useLongestToken","nextComponent","components","push","previousComponent","reverse","componentPos","componentLen","component","removed","slice","added","tmp","map","i","oldValue","finalComponent","equals","pop","exec","ret","path","oldPosInc","last","commonCount","left","right","comparator","ignoreCase","toLowerCase","array","split","chars","characterDiff","generateOptions","defaults","name","hasOwnProperty","extendedWordChars","reWhitespace","wordDiff","ignoreWhitespace","test","tokens","splice","lineDiff","diffLines","oldStr","newStr","stripTrailingCr","replace","retLines","linesAndNewlines","line","newlineIsToken","trim","sentenceDiff","cssDiff","_typeof","obj","Symbol","iterator","constructor","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","_objectSpread2","target","source","forEach","key","defineProperty","configurable","writable","getOwnPropertyDescriptors","defineProperties","_toConsumableArray","arr","_arrayWithoutHoles","Array","isArray","_arrayLikeToArray","_iterableToArray","iter","from","_unsupportedIterableToArray","o","minLen","n","toString","call","_nonIterableSpread","TypeError","len","arr2","objectPrototypeToString","jsonDiff","canonicalize","stack","replacementStack","replacer","canonicalizedObj","toJSON","_key","sortedKeys","sort","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","v","JSON","stringify","arrayDiff","parsePatch","uniDiff","diffstr","delimiters","match","list","parseFileHeader","index","fileHeader","keyPrefix","data","fileName","substr","parseIndex","header","hunks","_line","parseHunk","chunkHeaderIndex","chunkHeader","chunkHeaderLine","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation","strict","Error","applyPatch","removeEOFNL","addEOFNL","compareLine","lineNumber","patchContent","errorCount","fuzzFactor","minLine","offset","maxLine","localOffset","toPos","distanceIterator","start","wantForward","backwardExhausted","forwardExhausted","hunkFits","j","content","diffOffset","_i","_hunk","_toPos","delimiter","previousOperation","_k","structuredPatch","oldFileName","newFileName","oldHeader","newHeader","context","oldRangeStart","newRangeStart","curRange","oldLine","newLine","_loop","current","prev","contextLines","_curRange","entry","_curRange2","_curRange3","contextSize","oldEOFNewline","newEOFNewline","noNlBeforeAdds","formatPatch","createTwoFilesPatch","arrayStartsWith","loadPatch","param","base","fileNameChanged","patch","selectField","mine","theirs","conflict","hunkBefore","check","cloneHunk","removal","their","swap","_hunk$lines6","myChanges","collectChange","theirChanges","collectContext","state","matchChanges","changes","merged","matchIndex","contextChanges","conflicted","change","insertLeading","insert","insertTrailing","allRemoves","reduce","skipRemoveSuperset","removeChanges","delta","changeContent","applyPatches","currentIndex","processIndex","complete","loadFile","err","updatedContent","patched","convertChangesToDMP","convertChangesToXML","escapeHTML","s","createPatch","diffArrays","oldArr","newArr","diffChars","diffCss","diffJson","oldObj","newObj","diffSentences","diffTrimmedLines","diffWords","diffWordsWithSpace","merge","mineIndex","theirsIndex","mineOffset","theirsOffset","mineCurrent","theirsCurrent","mergedHunk","mergeLines","mineLines","theirOffset","theirLines","_calcOldNewLineCount","_hunk$lines","_hunk$lines2","theirCurrent","mutualChange","_hunk$lines3","_hunk$lines4","_hunk$lines5","a","b","calcOldNewLineCount","myCount","theirCount","reversePatch","l","startsWith","concat","console","log","document","getElementById","addEventListener","text1","text2","display","part","color","innerHTML","htmlContent","navigator","clipboard","write","ClipboardItem","Blob","type","then","alert","error"],"version":3,"file":"index.6e6c7e4e.js.map"}